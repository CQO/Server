// Generated by CoffeeScript 1.10.0
(function() {
  var _authorizeConnection, authorizeConnection, logger;

  logger = new Logger('StreamBroadcast', {
    sections: {
      connection: 'Connection',
      auth: 'Auth',
      stream: 'Stream'
    }
  });

  _authorizeConnection = function(instance) {
    logger.auth.info("Authorizing with " + instance);
    return connections[instance].call('broadcastAuth', connections[instance].instanceRecord._id, InstanceStatus.id(), function(err, ok) {
      if (err != null) {
        return logger.auth.error("broadcastAuth error " + instance + " " + connections[instance].instanceRecord._id + " " + (InstanceStatus.id()), err);
      }
      connections[instance].broadcastAuth = ok;
      return logger.auth.info("broadcastAuth with " + instance, ok);
    });
  };

  authorizeConnection = function(instance) {
    if (InstanceStatus.getCollection().findOne({
      _id: InstanceStatus.id()
    }) == null) {
      return Meteor.setTimeout(function() {
        return authorizeConnection(instance);
      }, 500);
    }
    return _authorizeConnection(instance);
  };

  this.connections = {};

  this.startStreamBroadcast = function() {
    var base, broadcast;
    if ((base = process.env).INSTANCE_IP == null) {
      base.INSTANCE_IP = 'localhost';
    }
    logger.info('startStreamBroadcast');
    InstanceStatus.getCollection().find({
      'extraInformation.port': {
        $exists: true
      }
    }, {
      sort: {
        _createdAt: -1
      }
    }).observe({
      added: function(record) {
        var instance, ref;
        instance = record.extraInformation.host + ":" + record.extraInformation.port;
        if (record.extraInformation.port === process.env.PORT && record.extraInformation.host === process.env.INSTANCE_IP) {
          logger.auth.info("prevent self connect", instance);
          return;
        }
        if (record.extraInformation.host === process.env.INSTANCE_IP) {
          instance = "localhost:" + record.extraInformation.port;
        }
        if (((ref = connections[instance]) != null ? ref.instanceRecord : void 0) != null) {
          if (connections[instance].instanceRecord._createdAt < record._createdAt) {
            connections[instance].disconnect();
            delete connections[instance];
          } else {
            return;
          }
        }
        logger.connection.info('connecting in', instance);
        connections[instance] = DDP.connect(instance, {
          _dontPrintErrors: true
        });
        connections[instance].instanceRecord = record;
        return connections[instance].onReconnect = function() {
          return authorizeConnection(instance);
        };
      },
      removed: function(record) {
        var instance;
        instance = record.extraInformation.host + ":" + record.extraInformation.port;
        if (record.extraInformation.host === process.env.INSTANCE_IP) {
          instance = "localhost:" + record.extraInformation.port;
        }
        if ((connections[instance] != null) && (InstanceStatus.getCollection().findOne({
          'extraInformation.host': record.extraInformation.host,
          'extraInformation.port': record.extraInformation.port
        }) == null)) {
          logger.connection.info('disconnecting from', instance);
          connections[instance].disconnect();
          return delete connections[instance];
        }
      }
    });
    broadcast = function(streamName, eventName, args, userId) {
      var connection, fromInstance, instance, results;
      fromInstance = process.env.INSTANCE_IP + ':' + process.env.PORT;
      results = [];
      for (instance in connections) {
        connection = connections[instance];
        results.push((function(instance, connection) {
          if (connection.status().connected === true) {
            return connection.call('stream', streamName, eventName, args, function(error, response) {
              if (error != null) {
                logger.error("Stream broadcast error", error);
              }
              switch (response) {
                case 'self-not-authorized':
                  logger.stream.error(("Stream broadcast from '" + fromInstance + "' to '" + connection._stream.endpoint + "' with name " + streamName + " to self is not authorized").red);
                  logger.stream.debug("    -> connection authorized".red, connection.broadcastAuth);
                  logger.stream.debug("    -> connection status".red, connection.status());
                  return logger.stream.debug("    -> arguments".red, eventName, args);
                case 'not-authorized':
                  logger.stream.error(("Stream broadcast from '" + fromInstance + "' to '" + connection._stream.endpoint + "' with name " + streamName + " not authorized").red);
                  logger.stream.debug("    -> connection authorized".red, connection.broadcastAuth);
                  logger.stream.debug("    -> connection status".red, connection.status());
                  logger.stream.debug("    -> arguments".red, eventName, args);
                  return authorizeConnection(instance);
                case 'stream-not-exists':
                  logger.stream.error(("Stream broadcast from '" + fromInstance + "' to '" + connection._stream.endpoint + "' with name " + streamName + " does not exist").red);
                  logger.stream.debug("    -> connection authorized".red, connection.broadcastAuth);
                  logger.stream.debug("    -> connection status".red, connection.status());
                  return logger.stream.debug("    -> arguments".red, eventName, args);
              }
            });
          }
        })(instance, connection));
      }
      return results;
    };
    Meteor.StreamerCentral.on('broadcast', function(streamName, eventName, args) {
      return broadcast(streamName, eventName, args);
    });
    return Meteor.methods({
      broadcastAuth: function(selfId, remoteId) {
        check(selfId, String);
        check(remoteId, String);
        this.unblock();
        if (selfId === InstanceStatus.id() && remoteId !== InstanceStatus.id() && (InstanceStatus.getCollection().findOne({
          _id: remoteId
        }) != null)) {
          this.connection.broadcastAuth = true;
        }
        return this.connection.broadcastAuth === true;
      },
      stream: function(streamName, eventName, args) {
        if (this.connection == null) {
          return 'self-not-authorized';
        }
        if (this.connection.broadcastAuth !== true) {
          return 'not-authorized';
        }
        if (Meteor.StreamerCentral.instances[streamName] == null) {
          return 'stream-not-exists';
        }
        Meteor.StreamerCentral.instances[streamName]._emit(eventName, args);
        return void 0;
      }
    });
  };

  Meteor.startup(function() {
    return startStreamBroadcast();
  });

}).call(this);
