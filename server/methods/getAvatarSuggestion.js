// Generated by CoffeeScript 1.10.0
(function() {
  this.getAvatarSuggestionForUser = function(user) {
    var avatar, avatars, blob, e, email, error, i, j, k, len, len1, len2, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, result, validAvatars;
    check(user, Object);
    avatars = [];
    if ((((ref = user.services.facebook) != null ? ref.id : void 0) != null) && RocketChat.settings.get('Accounts_OAuth_Facebook')) {
      avatars.push({
        service: 'facebook',
        url: "https://graph.facebook.com/" + user.services.facebook.id + "/picture?type=large"
      });
    }
    if ((((ref1 = user.services.google) != null ? ref1.picture : void 0) != null) && user.services.google.picture !== "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg" && RocketChat.settings.get('Accounts_OAuth_Google')) {
      avatars.push({
        service: 'google',
        url: user.services.google.picture
      });
    }
    if ((((ref2 = user.services.github) != null ? ref2.username : void 0) != null) && RocketChat.settings.get('Accounts_OAuth_Github')) {
      avatars.push({
        service: 'github',
        url: "https://avatars.githubusercontent.com/" + user.services.github.username + "?s=200"
      });
    }
    if ((((ref3 = user.services.linkedin) != null ? ref3.pictureUrl : void 0) != null) && RocketChat.settings.get('Accounts_OAuth_Linkedin')) {
      avatars.push({
        service: 'linkedin',
        url: user.services.linkedin.pictureUrl
      });
    }
    if ((((ref4 = user.services.twitter) != null ? ref4.profile_image_url_https : void 0) != null) && RocketChat.settings.get('Accounts_OAuth_Twitter')) {
      avatars.push({
        service: 'twitter',
        url: user.services.twitter.profile_image_url_https
      });
    }
    if ((((ref5 = user.services.gitlab) != null ? ref5.avatar_url : void 0) != null) && RocketChat.settings.get('Accounts_OAuth_Gitlab')) {
      avatars.push({
        service: 'gitlab',
        url: user.services.gitlab.avatar_url
      });
    }
    if ((((ref6 = user.services.sandstorm) != null ? ref6.picture : void 0) != null) && Meteor.settings["public"].sandstorm) {
      avatars.push({
        service: 'sandstorm',
        url: user.services.sandstorm.picture
      });
    }
    if (((ref7 = user.emails) != null ? ref7.length : void 0) > 0) {
      ref8 = user.emails;
      for (i = 0, len = ref8.length; i < len; i++) {
        email = ref8[i];
        if (email.verified === true) {
          avatars.push({
            service: 'gravatar',
            url: Gravatar.imageUrl(email.address, {
              "default": '404',
              size: 200,
              secure: true
            })
          });
        }
      }
      ref9 = user.emails;
      for (j = 0, len1 = ref9.length; j < len1; j++) {
        email = ref9[j];
        if (email.verified !== true) {
          avatars.push({
            service: 'gravatar',
            url: Gravatar.imageUrl(email.address, {
              "default": '404',
              size: 200,
              secure: true
            })
          });
        }
      }
    }
    validAvatars = {};
    for (k = 0, len2 = avatars.length; k < len2; k++) {
      avatar = avatars[k];
      try {
        result = HTTP.get(avatar.url, {
          npmRequestOptions: {
            encoding: 'binary'
          }
        });
        if (result.statusCode === 200) {
          blob = "data:" + result.headers['content-type'] + ";base64,";
          blob += Buffer(result.content, 'binary').toString('base64');
          avatar.blob = blob;
          avatar.contentType = result.headers['content-type'];
          validAvatars[avatar.service] = avatar;
        }
      } catch (error) {
        e = error;
      }
    }
    return validAvatars;
  };

  Meteor.methods({
    getAvatarSuggestion: function() {
      var user;
      if (!Meteor.userId()) {
        throw new Meteor.Error('error-invalid-user', 'Invalid user', {
          method: 'getAvatarSuggestion'
        });
      }
      this.unblock();
      user = Meteor.user();
      return getAvatarSuggestionForUser(user);
    }
  });

}).call(this);
