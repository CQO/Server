// Generated by CoffeeScript 1.10.0
(function() {
  var Api;

  Api = new Restivus({
    useDefaultAuth: true,
    prettyJson: true,
    enableCors: false
  });

  Api.addRoute('info', {
    authRequired: false
  }, {
    get: function() {
      return RocketChat.Info;
    }
  });

  Api.addRoute('version', {
    authRequired: false
  }, {
    get: function() {
      var version;
      version = {
        api: '0.1',
        rocketchat: '0.5'
      };
      return {
        status: 'success',
        versions: version
      };
    }
  });

  Api.addRoute('publicRooms', {
    authRequired: true
  }, {
    get: function() {
      var rooms;
      rooms = RocketChat.models.Rooms.findByType('c', {
        sort: {
          msgs: -1
        }
      }).fetch();
      return {
        status: 'success',
        rooms: rooms
      };
    }
  });


  /*
  @api {get} /joinedRooms Get joined rooms.
   */

  Api.addRoute('joinedRooms', {
    authRequired: true
  }, {
    get: function() {
      var rooms;
      rooms = RocketChat.models.Rooms.findByContainigUsername(this.user.username).fetch();
      return {
        status: 'success',
        rooms: rooms
      };
    }
  });

  Api.addRoute('rooms/:id/join', {
    authRequired: true
  }, {
    post: function() {
      Meteor.runAsUser(this.userId, (function(_this) {
        return function() {
          return Meteor.call('joinRoom', _this.urlParams.id);
        };
      })(this));
      return {
        status: 'success'
      };
    }
  });

  Api.addRoute('rooms/:id/leave', {
    authRequired: true
  }, {
    post: function() {
      Meteor.runAsUser(this.userId, (function(_this) {
        return function() {
          return Meteor.call('leaveRoom', _this.urlParams.id);
        };
      })(this));
      return {
        status: 'success'
      };
    }
  });


  /*
  @api {get} /rooms/:id/messages?skip=:skip&limit=:limit Get messages in a room.
  @apiParam {Number} id         Room ID
  @apiParam {Number} [skip=0]   Number of results to skip at the beginning
  @apiParam {Number} [limit=50] Maximum number of results to return
   */

  Api.addRoute('rooms/:id/messages', {
    authRequired: true
  }, {
    get: function() {
      var e, error, limit, msgs, rid, skip;
      try {
        rid = this.urlParams.id;
        skip = this.queryParams.skip | 0 || 0;
        limit = this.queryParams.limit | 0 || 50;
        if (limit > 50) {
          limit = 50;
        }
        if (Meteor.call('canAccessRoom', rid, this.userId)) {
          msgs = RocketChat.models.Messages.findVisibleByRoomId(rid, {
            sort: {
              ts: -1
            },
            skip: skip,
            limit: limit
          }).fetch();
          return {
            status: 'success',
            messages: msgs
          };
        } else {
          return {
            statusCode: 403,
            body: {
              status: 'fail',
              message: 'Cannot access room.'
            }
          };
        }
      } catch (error) {
        e = error;
        return {
          statusCode: 400,
          body: {
            status: 'fail',
            message: e.name + ' :: ' + e.message
          }
        };
      }
    }
  });

  Api.addRoute('rooms/:id/send', {
    authRequired: true
  }, {
    post: function() {
      Meteor.runAsUser(this.userId, (function(_this) {
        return function() {
          console.log(_this.bodyParams.msg);
          return Meteor.call('sendMessage', {
            msg: _this.bodyParams.msg,
            rid: _this.urlParams.id
          });
        };
      })(this));
      return {
        status: 'success'
      };
    }
  });

  Api.addRoute('rooms/:id/online', {
    authRequired: true
  }, {
    get: function() {
      var i, j, len, online, onlineInRoom, room, user;
      room = RocketChat.models.Rooms.findOneById(this.urlParams.id);
      online = RocketChat.models.Users.findUsersNotOffline({
        fields: {
          username: 1,
          status: 1
        }
      }).fetch();
      onlineInRoom = [];
      for (i = j = 0, len = online.length; j < len; i = ++j) {
        user = online[i];
        if (room.usernames.indexOf(user.username) !== -1) {
          onlineInRoom.push(user.username);
        }
      }
      return {
        status: 'success',
        online: onlineInRoom
      };
    }
  });

  Api.testapiValidateUsers = function(users) {
    var error, i, j, len, nameValidation, user;
    for (i = j = 0, len = users.length; j < len; i = ++j) {
      user = users[i];
      if (user.name != null) {
        if (user.email != null) {
          if (user.pass != null) {
            try {
              nameValidation = new RegExp('^' + RocketChat.settings.get('UTF8_Names_Validation') + '$', 'i');
            } catch (error) {
              nameValidation = new RegExp('^[0-9a-zA-Z-_.]+$', 'i');
            }
            if (nameValidation.test(user.name)) {
              if (/\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]+\b/i.test(user.email)) {
                continue;
              }
            }
          }
        }
      }
      throw new Meteor.Error('invalid-user-record', "[restapi] bulk/register -> record #" + i + " is invalid");
    }
  };


  /*
  @api {post} /bulk/register  Register multiple users based on an input array.
  @apiName register
  @apiGroup TestAndAdminAutomation
  @apiVersion 0.0.1
  @apiDescription  Caller must have 'testagent' or 'adminautomation' role.
  NOTE:   remove room is NOT recommended; use Meteor.reset() to clear db and re-seed instead
  @apiParam {json} rooms An array of users in the body of the POST.
  @apiParamExample {json} POST Request Body example:
    {
      'users':[ {'email': 'user1@user1.com',
                 'name': 'user1',
                 'pass': 'abc123' },
                {'email': 'user2@user2.com',
                 'name': 'user2',
                 'pass': 'abc123'},
                ...
              ]
    }
  @apiSuccess {json} ids An array of IDs of the registered users.
  @apiSuccessExample {json} Success-Response:
    HTTP/1.1 200 OK
    {
      'ids':[ {'uid': 'uid_1'},
              {'uid': 'uid_2'},
              ...
      ]
    }
   */

  Api.addRoute('bulk/register', {
    authRequired: true
  }, {
    post: {
      action: function() {
        var e, endCount, error, i, ids, incoming, j, len, ref;
        if (RocketChat.authz.hasPermission(this.userId, 'bulk-register-user')) {
          try {
            Api.testapiValidateUsers(this.bodyParams.users);
            this.response.setTimeout(500 * this.bodyParams.users.length);
            ids = [];
            endCount = this.bodyParams.users.length - 1;
            ref = this.bodyParams.users;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              incoming = ref[i];
              ids[i] = {
                uid: Meteor.call('registerUser', incoming)
              };
              Meteor.runAsUser(ids[i].uid, (function(_this) {
                return function() {
                  Meteor.call('setUsername', incoming.name);
                  return Meteor.call('joinDefaultChannels');
                };
              })(this));
            }
            return {
              status: 'success',
              ids: ids
            };
          } catch (error) {
            e = error;
            return {
              statusCode: 400,
              body: {
                status: 'fail',
                message: e.name + ' :: ' + e.message
              }
            };
          }
        } else {
          console.log('[restapi] bulk/register -> '.red, "User does not have 'bulk-register-user' permission");
          return {
            statusCode: 403,
            body: {
              status: 'error',
              message: 'You do not have permission to do this'
            }
          };
        }
      }
    }
  });

  Api.testapiValidateRooms = function(rooms) {
    var error, i, j, len, nameValidation, room;
    for (i = j = 0, len = rooms.length; j < len; i = ++j) {
      room = rooms[i];
      if (room.name != null) {
        if (room.members != null) {
          if (room.members.length > 1) {
            try {
              nameValidation = new RegExp('^' + RocketChat.settings.get('UTF8_Names_Validation') + '$', 'i');
            } catch (error) {
              nameValidation = new RegExp('^[0-9a-zA-Z-_.]+$', 'i');
            }
            if (nameValidation.test(room.name)) {
              continue;
            }
          }
        }
      }
      throw new Meteor.Error('invalid-room-record', "[restapi] bulk/createRoom -> record #" + i + " is invalid");
    }
  };


  /*
  @api {post} /bulk/createRoom Create multiple rooms based on an input array.
  @apiName createRoom
  @apiGroup TestAndAdminAutomation
  @apiVersion 0.0.1
  @apiParam {json} rooms An array of rooms in the body of the POST. 'name' is room name, 'members' is array of usernames
  @apiParamExample {json} POST Request Body example:
    {
      'rooms':[ {'name': 'room1',
                 'members': ['user1', 'user2']
                },
                {'name': 'room2',
                 'members': ['user1', 'user2', 'user3']
                }
                ...
              ]
    }
  @apiDescription  Caller must have 'testagent' or 'adminautomation' role.
  NOTE:   remove room is NOT recommended; use Meteor.reset() to clear db and re-seed instead
  
  @apiSuccess {json} ids An array of ids of the rooms created.
  @apiSuccessExample {json} Success-Response:
    HTTP/1.1 200 OK
    {
      'ids':[ {'rid': 'rid_1'},
              {'rid': 'rid_2'},
              ...
      ]
    }
   */

  Api.addRoute('bulk/createRoom', {
    authRequired: true
  }, {
    post: {
      action: function() {
        var e, error, ids;
        if (RocketChat.authz.hasPermission(this.userId, 'bulk-create-c')) {
          try {
            this.response.setTimeout(1000 * this.bodyParams.rooms.length);
            Api.testapiValidateRooms(this.bodyParams.rooms);
            ids = [];
            Meteor.runAsUser(this.userId, (function(_this) {
              return function() {
                var i, incoming, j, len, ref, results;
                ref = _this.bodyParams.rooms;
                results = [];
                for (i = j = 0, len = ref.length; j < len; i = ++j) {
                  incoming = ref[i];
                  results.push(ids[i] = Meteor.call('createChannel', incoming.name, incoming.members));
                }
                return results;
              };
            })(this));
            return {
              status: 'success',
              ids: ids
            };
          } catch (error) {
            e = error;
            return {
              statusCode: 400,
              body: {
                status: 'fail',
                message: e.name + ' :: ' + e.message
              }
            };
          }
        } else {
          console.log('[restapi] bulk/createRoom -> '.red, "User does not have 'bulk-create-c' permission");
          return {
            statusCode: 403,
            body: {
              status: 'error',
              message: 'You do not have permission to do this'
            }
          };
        }
      }
    }
  });

}).call(this);
