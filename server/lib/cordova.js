// Generated by CoffeeScript 1.10.0
(function() {
  var configurePush, sendPush;

  Meteor.methods({
    log: function() {
      return console.log.apply(console, arguments);
    },
    push_test: function() {
      var query, tokens, user;
      user = Meteor.user();
      if (user == null) {
        throw new Meteor.Error('error-not-allowed', 'Not allowed', {
          method: 'push_test'
        });
      }
      if (!RocketChat.authz.hasRole(user._id, 'admin')) {
        throw new Meteor.Error('error-not-allowed', 'Not allowed', {
          method: 'push_test'
        });
      }
      if (Push.enabled !== true) {
        throw new Meteor.Error('error-push-disabled', 'Push is disabled', {
          method: 'push_test'
        });
      }
      query = {
        $and: [
          {
            userId: user._id
          }, {
            $or: [
              {
                'token.apn': {
                  $exists: true
                }
              }, {
                'token.gcm': {
                  $exists: true
                }
              }
            ]
          }
        ]
      };
      tokens = Push.appCollection.find(query).count();
      if (tokens === 0) {
        throw new Meteor.Error('error-no-tokens-for-this-user', "There are no tokens for this user", {
          method: 'push_test'
        });
      }
      Push.send({
        from: 'push',
        title: "@" + user.username,
        text: TAPi18n.__("This_is_a_push_test_messsage"),
        apn: {
          text: ("@" + user.username + ":\n") + TAPi18n.__("This_is_a_push_test_messsage")
        },
        sound: 'chime',
        query: {
          userId: user._id
        }
      });
      return {
        message: "Your_push_was_sent_to_s_devices",
        params: [tokens]
      };
    }
  });

  configurePush = function() {
    var apn, gcm;
    if (RocketChat.settings.get('Push_debug')) {
      Push.debug = true;
      console.log('Push: configuring...');
    }
    if (RocketChat.settings.get('Push_enable') === true) {
      Push.allow({
        send: function(userId, notification) {
          return RocketChat.authz.hasRole(userId, 'admin');
        }
      });
      apn = void 0;
      gcm = void 0;
      if (RocketChat.settings.get('Push_enable_gateway') === false) {
        gcm = {
          apiKey: RocketChat.settings.get('Push_gcm_api_key'),
          projectNumber: RocketChat.settings.get('Push_gcm_project_number')
        };
        apn = {
          passphrase: RocketChat.settings.get('Push_apn_passphrase'),
          keyData: RocketChat.settings.get('Push_apn_key'),
          certData: RocketChat.settings.get('Push_apn_cert')
        };
        if (RocketChat.settings.get('Push_production') !== true) {
          apn = {
            passphrase: RocketChat.settings.get('Push_apn_dev_passphrase'),
            keyData: RocketChat.settings.get('Push_apn_dev_key'),
            certData: RocketChat.settings.get('Push_apn_dev_cert'),
            gateway: 'gateway.sandbox.push.apple.com'
          };
        }
        if ((apn.keyData == null) || apn.keyData.trim() === '' || (apn.keyData == null) || apn.keyData.trim() === '') {
          apn = void 0;
        }
        if ((gcm.apiKey == null) || gcm.apiKey.trim() === '' || (gcm.projectNumber == null) || gcm.projectNumber.trim() === '') {
          gcm = void 0;
        }
      }
      Push.Configure({
        apn: apn,
        gcm: gcm,
        production: RocketChat.settings.get('Push_production'),
        sendInterval: 1000,
        sendBatchSize: 10
      });
      if (RocketChat.settings.get('Push_enable_gateway') === true) {
        Push.serverSend = function(options) {
          var query;
          options = options || {
            badge: 0
          };
          query = void 0;
          if (options.from !== '' + options.from) {
            throw new Error('Push.send: option "from" not a string');
          }
          if (options.title !== '' + options.title) {
            throw new Error('Push.send: option "title" not a string');
          }
          if (options.text !== '' + options.text) {
            throw new Error('Push.send: option "text" not a string');
          }
          if (RocketChat.settings.get('Push_debug')) {
            console.log('Push: send message "' + options.title + '" via query', options.query);
          }
          query = {
            $and: [
              options.query, {
                $or: [
                  {
                    'token.apn': {
                      $exists: true
                    }
                  }, {
                    'token.gcm': {
                      $exists: true
                    }
                  }
                ]
              }
            ]
          };
          return Push.appCollection.find(query).forEach(function(app) {
            var service, token;
            if (RocketChat.settings.get('Push_debug')) {
              console.log('Push: send to token', app.token);
            }
            if (app.token.apn != null) {
              service = 'apn';
              token = app.token.apn;
            } else if (app.token.gcm != null) {
              service = 'gcm';
              token = app.token.gcm;
            }
            return sendPush(service, token, options);
          });
        };
      }
      return Push.enabled = true;
    }
  };

  sendPush = function(service, token, options, tries) {
    var data;
    if (tries == null) {
      tries = 0;
    }
    data = {
      data: {
        token: token,
        options: options
      }
    };
    return HTTP.post(RocketChat.settings.get('Push_gateway') + ("/push/" + service + "/send"), data, function(error, response) {
      var milli;
      if ((response != null ? response.statusCode : void 0) === 406) {
        console.log('removing push token', token);
        Push.appCollection.remove({
          $or: [
            {
              'token.apn': token
            }, {
              'token.gcm': token
            }
          ]
        });
        return;
      }
      if (error == null) {
        return;
      }
      SystemLogger.error('Error sending push to gateway (' + tries + ' try) ->', error);
      if (tries <= 6) {
        milli = Math.pow(10, tries + 2);
        SystemLogger.log('Trying sending push to gateway again in', milli, 'milliseconds');
        return Meteor.setTimeout(function() {
          return sendPush(service, token, options, tries + 1);
        }, milli);
      }
    });
  };

  Meteor.startup(function() {
    return configurePush();
  });

}).call(this);
